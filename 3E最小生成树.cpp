// 最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，
//则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。
// 可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，
//赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，
//每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。
//这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。
// 而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。以下是其算法的大致结构：
//在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。

//输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。
//以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，
//则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。
//输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。

//只有一个整数，即最小生成树的总代价。请注意行尾输出换行。

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 50; // 顶点数上限
const int INF = 0x3f3f3f3f;

int n;
int g[N][N]; // 邻接矩阵
int dist[N]; // 距离数组
bool st[N];  // 标记数组

int prim() {
    memset(dist, 0x3f, sizeof dist);//将距离初始化为无穷远
    int res = 0; // 最小生成树的总代价
    dist[0] = 0; // 从第一个顶点开始
    for (int i = 0; i < n; i++) 
    {
        int t = -1;
        // 找到距离集合最近的未被选中的点
        for (int j = 0; j < n; j++) 
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))//这个点没有被找过同时  
            {
                t = j;
            }
        }
        // 如果 dist[t] 为 INF，说明图是不连通的
        if (dist[t] == INF) {
            return INF;
        }
        // 将点 t 加入生成树集合
        st[t] = true;
        res += dist[t];
        // 更新 dist 数组
        for (int j = 0; j < n; j++) {
            if (!st[j] && g[t][j] < dist[j]) {
                dist[j] = g[t][j];
            }
        }
    }
    return res;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> g[i][j];
            if (i != j && g[i][j] == 0) {
                g[i][j] = INF;
            }
        }
    }

    int result = prim();
    cout << result << endl;
    return 0;
}
